# Vector

В этом задании вам необходимо реализовать простой аналог класса
[std::vector](https://en.cppreference.com/w/cpp/container/vector).

Вектор принимает один шаблонный параметр `T` &mdash; тип хранимых элементов.

> **Note**
>
> `std::vector` также принимает необязательным вторым шаблонным параметром
> тип используемого аллокатора, но вам таким заниматься не надо &mdash;
> достаточно использовать операторы `new`/`delete`.

В [vector.h](src/vector.h) возле каждого метода, который необходимо реализовать,
указаны требуемые гарантии безопасности исключений и вычислительная сложность.

Обратите внимание, что несмотря на то, что стандарт определяет
`std::vector::shrink_to_fit` как "non-binding request" (т.е. допускается
реализация, которая ничего не делает), ваша версия этого метода обязана
уменьшать `capacity`, если это имеет смысл.

Деструкторы элементов должны вызываться в порядке, обратном порядку их вставки.

Для обеспечения строгой гарантии безопасности исключений, в зависимости от того, помечен ли move-конструктор `T` спецификатором `noexcept`, может потребоваться вместо него вызывать конструктор копирования. Чтобы не копировать лишний раз, предлагается воспользоваться функцией из стандартной библиотеки [`std::move_if_noexcept(x)`](https://en.cppreference.com/w/cpp/utility/move_if_noexcept), которая действует как `std::move` тогда и только тогда, когда конструктор перемещения для `x` помечен `noexcept`. Когда вы познакомитесь с шаблонами, вы научитесь и сами реализовывать подобные функции.
